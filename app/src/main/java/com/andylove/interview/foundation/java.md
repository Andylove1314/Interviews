**java基础**
1， 泛型Generic
### 定义：
  i. 从Java 5开始，引入了“参数化类型”（Parameterized Type）的概念，改造了所有的Java集合，使之都实现泛型，允许程序在创建集合时就可以指定集合元素的类型，比如List<String>就表名这是一个只能存放String类型的List；
  ii. 泛型（Generic）：就是指参数化类型，上面的List<String>就是参数化类型(像法法的形参一样)，因此就是泛型，而String就是该List<String>泛型的类型参数；
  
### 定义泛型类、接口：
  1) 不仅Java的集合都定义成了泛型，用户自己也可以定义任意泛型的类、接口，只要在定义它们时用<>来指定类型参数即可；
  2) 例如：public class Fruit<T> { ... }，其中<T>指定了该泛型的类型参数，这个T是一个类型参数名，用户可以任意命名（就像方法参数的形参名一样），只有在定义该泛型的对象时将T替换成指定的具体类型从而产生一个实例化的泛型对象，例如：MyGeneric<String> fruit = new Fruit<>(...);
  3) 类型形参可以在整个接口、类体内当成普通类型使用，集合所有可使用普通类型的地方都可以使用类型形参，例如：
### 泛型通配符
同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的,编译要求
所以用通配符就出现了，类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。
当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。
### 泛型方法
泛型类，接口，是在实例化类引用的时候指明泛型的具体类型（如果不需要使用类型的具体功能时，可以用通配符？代替）；
泛型方法，是在调用方法的时候指明泛型的具体类型 。
    
    注：泛型方法可以多参数;
        静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。
        
 ### HashMap、LinkedHashMap、TreeMap区别
  1，Map定义：
    Map主要用于存储健值对，根据键得到值，因此不允许键重复（重复了覆盖了），但允许值重复。即键值对集合。
       
    （1）HashMap ：
        HashMap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。
        　　HashMap最多只允许一条记录的键为Null；允许多条记录的值为 Null。
        　　HashMap不支持线程的同步（即任一时刻可以有多个线程同时写HashMap，线程不安全），可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。
        　　Hashtable与 HashMap类似，它继承自Dictionary类。不同的是：它不允许记录的键或者值为空；它支持线程的同步（即任一时刻只有一个线程能写Hashtable），因此也导致了 Hashtable在写入时会比较慢。
    （2）LinkedHashMap：
        LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。也可以在构造时带参数，按照应用次数排序。
        在遍历的时候会比HashMap慢，不过有种情况例外：当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢。因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。
    （3）TreeMap：
        TreeMap实现SortMap接口，能够把它保存的记录根据键排序。
    　　默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。
    （4）三种类型分别在什么时候使用
        1、一般情况下，我们用的最多的是HashMap。HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。
    　　2、TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。
    　　3、LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。
    （5）注意：
    　　1、Collection没有get()方法来取得某个元素。只能通过iterator()遍历元素。 
    　　2、Set和Collection拥有一模一样的接口。 
    　　3、List，可以通过get()方法来一次取出一个元素。使用数字来选择一堆对象中的一个，get(0)...。(add/get) 
    　　4、一般使用ArrayList。用LinkedList构造堆栈stack、队列queue。 
    　　5、Map用 put(k,v) / get(k)，还可以使用containsKey()/containsValue()来检查其中是否含有某个key/value。 
          　　HashMap会利用对象的hashCode来快速找到key。哈希码就是将对象的信息经过一些转变形成一个独一无二的int值，这个值存储在一个array中。我们都知道所有存储结构中，array查找速度是最快的。所以，可以加速查找。 发生碰撞时，让array指向多个values。即，数组每个位置上又生成一个梿表。 
    　　6、Map中元素，可以将key序列、value序列单独抽取出来。 
    　　　　使用keySet()抽取key序列，将map中的所有keys生成一个Set。 
    　　　　使用values()抽取value序列，将map中的所有values生成一个Collection。 
    　　　　为什么一个生成Set，一个生成Collection？那是因为，key总是独一无二的，value允许重复。
    
 ### 常见的数据结构
   数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。算法是为求解一个问题需要遵循的、被清楚指定的简单指令的集合。
   常见的数据结构：
   一、线性表
      线性表是最常用且最简单的一种数据结构，它是n个数据元素的有限序列。
      实现线性表的方式一般有两种，一种是使用数组存储线性表的元素，即用一组连续的存储单元依次存储线性表的数据元素。另一种是使用链表存储线性表的元素，即用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的）。
   1.数组实现
    
         数组是一种大小固定的数据结构，对线性表的所有操作都可以通过数组来实现。虽然数组一旦创建之后，它的大小就无法改变了，但是当数组不能再存储线性表中的新元素时，我们可以创建一个新的大的数组来替换当前数组。这样就可以使用数组实现动态的数据结构。
         数组实现的线性表优点在于可以通过下标来访问或者修改元素，比较高效，主要缺点在于插入和删除的花费开销较大，比如当在第一个位置前插入一个元素，那么首先要把所有的元素往后移动一个位置。为了提高在任意位置添加或者删除元素的效率，可以采用链式结构来实现线性表。
      
   2.链表
        
        链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列节点组成，这些节点不必在内存中相连。每个节点由数据部分Data和链部分Next，Next指向下一个节点，这样当添加或者删除时，只需要改变相关节点的Next的指向，效率很高。
        链表的实现还有其它的方式，常见的有循环单链表，双向链表，循环双向链表。 循环单链表 主要是链表的最后一个节点指向第一个节点，整体构成一个链环。 双向链表 主要是节点中包含两个指针部分，一个指向前驱元，一个指向后继元，JDK中LinkedList集合类的实现就是双向链表。 循环双向链表 是最后一个节点指向第一个节点。
     
   二、栈与队列
       栈和队列也是比较常见的数据结构，它们是比较特殊的线性表，因为对于栈来说，访问、插入和删除元素只能在栈顶进行，对于队列来说，元素只能从队列尾插入，从队列头访问和删除。
    
   1，栈
         
         栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈顶，对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者相当于删除最后一个元素。栈有时又叫作LIFO(Last In First Out)表，即后进先出。
   
   2，队列 
    
        队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。
   
   三、树与二叉树
     树型结构是一类非常重要的非线性数据结构，其中以树和二叉树最为常用
       
   1.树
       
       是由n（n>=1）个有限节点组成一个具有层次关系的集合。它具有以下特点：每个节点有零个或多个子节点；没有父节点的节点称为 根 节点；每一个非根节点有且只有一个 父节点 ；除了根节点外，每个子节点可以分为多个不相交的子树。
   2.二叉树基本概念
      
    定义：
    二叉树是每个节点最多有两棵子树的树结构。通常子树被称作“左子树”和“右子树”。二叉树常被用于实现二叉查找树和二叉堆。
   
    相关性质：
    二叉树的每个结点至多只有2棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。
    二叉树的第i层至多有2^(i-1)个结点；深度为k的二叉树至多有2^k-1个结点。
    一棵深度为k，且有2^k-1个节点的二叉树称之为 满二叉树 ；
    深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为 完全二叉树 。
      
    三种遍历方法：
    (1) 先序遍历 若二叉树为空，则空操作，否则先访问根节点，再先序遍历左子树，最后先序遍历右子树。 
    (2) 中序遍历 若二叉树为空，则空操作，否则先中序遍历左子树，再访问根节点，最后中序遍历右子树。
    (3) 后序遍历 若二叉树为空，则空操作，否则先后序遍历左子树访问根节点，再后序遍历右子树，最后访问根节点。  
    
    树和二叉树的区别：
    (1) 二叉树每个节点最多有2个子节点，树则无限制。 
    (2) 二叉树中节点的子树分为左子树和右子树，即使某节点只有一棵子树，也要指明该子树是左子树还是右子树，即二叉树是有序的。 
    (3) 树决不能为空，它至少有一个节点，而一棵二叉树可以是空的。  
      
   3.二叉查找树
   
    二叉查找树：
     就是二叉排序树，也叫二叉搜索树。二叉查找树或者是一棵空树，或者是具有下列性质的二叉树： 
    (1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    (2) 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
    (3) 左、右子树也分别为二叉排序树；
    (4) 没有键值相等的结点。
   
   
   4.平衡二叉树
   
    平衡二叉树又称AVL树，它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。
    
   5.红黑树
   
    红黑树是平衡二叉树的一种，它保证在最坏情况下基本动态集合操作的事件复杂度为O(log n)。红黑树和平衡二叉树区别如下：(1) 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。(2) 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。点击查看更多
   
   四、图
   
    图是一种较线性表和树更为复杂的数据结构，在线性表中，数据元素之间仅有线性关系，在树形结构中，数据元素之间有着明显的层次关系，而在图形结构中，节点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。图的应用相当广泛，特别是近年来的迅速发展，已经渗入到诸如语言学、逻辑学、物理、化学、电讯工程、计算机科学以及数学的其他分支中。
    
   出处：https://www.jianshu.com/p/230e6fde9c75
   
### Object类成员
  在java里面所有的对象都会继承Object类。
 
 1．clone方法
    
    保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。
 
 2．getClass方法

    final方法，获得运行时类型。
 
 3．toString方法
 
    该方法用得比较多，一般子类都有覆盖。
 
 4．finalize方法
 
    该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。
 
 5．equals方法
 
    该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。
 
 6．hashCode方法
   
    该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。
    一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。
 
 7．wait方法
 
    wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。
    调用该方法后当前线程进入睡眠状态，直到以下事件发生。
 
    （1）其他线程调用了该对象的notify方法。
 
    （2）其他线程调用了该对象的notifyAll方法。
 
    （3）其他线程调用了interrupt中断该线程。
 
    （4）时间间隔到了。
 
     此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。
 
 8．notify方法
 
    该方法唤醒在该对象上等待的某个线程。
 
 9．notifyAll方法
 
    该方法唤醒在该对象上等待的所有线程。
 
 ### wait、sleep的区别
 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。
 sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
 在调用sleep()方法的过程中，线程不会释放对象锁。
 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
 
    看demo SleepWait.java
    总之一句话：
    （1）sleep()不会释放锁对象给别的线程；
    （2）锁对象.wait()会释放锁对象给别的线程，自己暂停操作，想再次被唤醒，需要 锁对象.notify()或者锁对象.notifyAll()。
 
   