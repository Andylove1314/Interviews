**事件分发**

_一，输入事件_

    在Android系统中，从用户与应用的交互中截获事件的方法不止一种。
    如考虑截获用户界面内的事件，则可从用户与之交互的特定视图对象中捕获事件。 为此，View 类提供了多种方法。
    在您将用于构建布局的各种 View 类中，您可能会注意到几种看起来适用于 UI 事件的公共回调方法。 当该对象上发生相应的操作时，Android 框架会调用这些方法。 例如，在触摸一个视图对象（例如“按钮”）时，对该对象调用 onTouchEvent() 方法。不过，为了截获此事件，您必须扩展 View 类并重写该方法。 然而，为了处理此类事件而扩展每个视图对象并不现实。 正因如此，View 类还包含一系列嵌套接口以及您可以更加轻松定义的回调。如
    View.OnClickListener， View.OnLongClickListener，View.OnTouchListener，View.OnKeyListener， View.OnFocusChangeListener等。
    
    请注意，onClick() 回调没有返回值，但是其他某些事件侦听器方法必须返回布尔值。具体原因取决于事件。 对于这几个事件侦听器，必须返回布尔值的原因如下：
    
    onLongClick()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何点击侦听器，则返回 false。
    onKey()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。 也就是说，返回 true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何按键侦听器，则返回 false。
    onTouch()： 此方法返回一个布尔值，表示侦听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。 因此，如果在收到关闭操作事件时返回 false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。 因此，您无需执行事件内的任何其他操作，如手势或最终操作事件。
    请记住，硬按键事件总是传递给目前处于焦点的视图对象。它们从视图 层次结构的顶部开始分派，然后向下，直至到达合适的目的地。如果您的视图对象（或视图对象的子项）目前具有焦点，那么您可以看到事件经由 dispatchKeyEvent() 方法的分派过程。除了通过视图捕获按键事件，您还可以使用 onKeyDown() 和 onKeyUp() 接收 Activity 内部的所有事件。
    
    此外，考虑应用的文本输入时，请记住：许多设备只有软件输入法。 此类方法无需基于按键；某些可能使用语音输入、手写等。尽管输入法提供了类似键盘的界面，但它通常不会触发 onKeyDown() 系列的事件。除非您要将应用限制为带有硬键盘的设备，否则，在设计 UI 时切勿要求必须通过特定按键进行控制。 特别是，当用户按下返回键时，不要依赖这些方法验证输入；请改用 IME_ACTION_DONE 等操作让输入法知晓您的应用预计会作何反应，这样，可以通过一种有意义的方式更改其 UI。
    不要推断软件输入法应如何工作，只要相信它能够为应用提供已设置格式的文本即可。
    如果您从视图构建自定义组件，则将能够定义几种用作默认事件处理程序的回调方法。在有关自定义组件的文档中，您将了解某些用于事件处理的常见回调，其中包括：
    
    onKeyDown(int, KeyEvent)：在发生新的按键事件时调用
    onKeyUp(int, KeyEvent)：在发生按键弹起事件时调用
    onTrackballEvent(MotionEvent)：在发生轨迹球运动事件时调用
    onTouchEvent(MotionEvent)：在发生触摸屏运动事件时调用
    onFocusChanged(boolean, int, Rect)：在视图获得或失去焦点时调用
    还有一些其他方法值得您注意，尽管它们并非 View 类的一部分，但可能会直接影响所能采取的事件处理方式。 因此，在管理布局内更复杂的事件时，请考虑使用以下其他方法：
    
    Activity.dispatchTouchEvent(MotionEvent)：此方法允许 Activity 在分派给窗口之前截获所有触摸事件。
    ViewGroup.onInterceptTouchEvent(MotionEvent)：此方法允许 ViewGroup 监视分派给子视图的事件。
    ViewParent.requestDisallowInterceptTouchEvent(boolean)： 对父视图调用此方法表明不应使用 onInterceptTouchEvent(MotionEvent) 截获触摸事件。
   
   _二，触摸模式_
      
      当用户使用方向键或轨迹球导航用户界面时，必须聚焦到可操作项目上（如按钮），以便用户看到将接受输入的对象。 但是，如果设备具有触摸功能且用户开始通过触摸界面与之交互，则不再需要突出显示项目或聚焦到特定视图对象上。 因此，有一种交互模式称为“触摸模式”。
      对于支持触摸功能的设备，当用户触摸屏幕时，设备会立即进入触摸模式。 自此以后，只有 isFocusableInTouchMode() 为 true 的视图才可聚焦，如文本编辑小部件。其他可触摸的视图（如按钮）在用户触摸时不会获得焦点；按下时它们只是触发点击侦听器。
      无论何时，只要用户点击方向键或滚动轨迹球，设备就会退出触摸模式并找到一个视图使其获得焦点。 现在，用户可在不触摸屏幕的情况下继续与用户界面交互。
      整个系统（所有窗口和 Activity）都将保持触摸模式状态。要查询当前状态，您可以调用isInTouchMode() 来检查设备目前是否处于触摸模式。
      
   _三，焦点处理_
   
     该框架将处理例行焦点移动来响应用户输入。其中包括在视图被移除或隐藏时或在新视图变得可用时更改焦点。 视图对象表示愿意通过 isFocusable() 方法获得焦点。要设置视图能否获得焦点，请调用 setFocusable()。在触摸模式中，您可以使用 isFocusableInTouchMode() 查询视图是否允许聚焦，而且可以使用 setFocusableInTouchMode() 对此进行更改。
     焦点移动所使用的算法会查找指定方向上距离最近的元素。 在极少数情况下，默认算法可能与开发者的期望行为不一致。 在这些情况下，您可以在布局文件中显式重写以下 XML 属性：nextFocusDown、nextFocusLeft、nextFocusRight 和 nextFocusUp。 将其中一个属性添加到失去焦点的视图。 将属性的值定义为应该聚焦的视图的 ID。例如：
     <LinearLayout
         android:orientation="vertical"
         ... >
       <Button android:id="@+id/top"
               android:nextFocusUp="@+id/bottom"
               ... />
       <Button android:id="@+id/bottom"
               android:nextFocusDown="@+id/top"
               ... />
     </LinearLayout>
     一般来说，在此垂直布局中，从第一个按钮向上导航或从第二个按钮向下导航，焦点都不会移到任何其他位置。 现在，顶部按钮已将底部按钮定义为 nextFocusUp（反之亦然），因而导航焦点将自上而下和自下而上循环往复。
     若要将一个视图声明为在 UI 中可聚焦（传统上并非如此），请在布局声明中将 android:focusable XML 属性添加到该视图。将值设置为 true。 此外，您还可以使用 android:focusableInTouchMode 将视图声明为在触摸模式下可聚焦。
     要请求要获得焦点的特定视图，请调用 requestFocus()。
     
   _四，手势_
   
      当用户将一个或多个手指放在触摸屏上并且您的应用将该触摸模式解释为特定手势时，发生“触摸手势”。
      手势检测分别有两个阶段：
      1，收集有关触摸事件的数据。
      2，解释数据以查看它是否符合您的应用支持的任何手势的条件。
      
   _五，捕获Activity或View的触摸事件_
   
      1，要拦截活动或视图中的触摸事件，请覆盖onTouchEvent()回调。您可以对这些事件进行自己的处理，以确定是否发生了手势。这是您需要为自定义手势执行的处理。
      2，但是，如果您的应用使用常用手势，例如双击，长按，弹出等，您可以利用该GestureDetector。GestureDetector使你可以轻松检测常见手势，而无需自行处理单个触摸事件。
      
   六，自定义视图组件
   
      使用它们执行操作的示例：
      1，您可以创建一个完全自定义渲染的视图类型，例如使用2D图形渲染的“音量控制”旋钮，类似于模拟电子控件。
      2，您可以将一组View组件组合成一个新的单个组件，可能是为了制作类似ComboBox（弹出列表和自由输入文本字段的组合），双窗格选择器控件（左侧和右侧窗格，其中包含一个列表）每个你可以重新分配哪个项目在哪个列表中），等等。
      3，您可以覆盖EditText组件在屏幕上呈现的方式（ Notepad Tutorial使用它可以很好地创建带衬里的记事本页面）。
      4，您可以捕获其他事件，如按键，并以某种自定义方式处理它们（例如游戏）。
      
      基本方法：
      1，View使用您自己的类 扩展现有的类或子类。
      2，覆盖超类中的一些方法。这些超类方法重写下手“ on”，例如onDraw()， onMeasure()和 onKeyDown()。这是类似on...的事件，Activity 或者ListActivity 是你改写生命周期和其他功能挂钩。
      3，使用新的扩展类。完成后，可以使用新的扩展类来代替它所基于的视图。
      
      框架调用视图的一些其他标准方法的摘要：
      1，Creation	
      Constructors   在从代码创建视图时调用构造函数的形式，以及在从布局文件中扩展视图时调用的窗体。第二个表单应解析并应用布局文件中定义的任何属性。
      onFinishInflate()  在视图之后调用，并且其所有子项都已从XML中填充。
      2，Layout
      onMeasure(int, int) 调用以确定此视图及其所有子项的大小要求。
      onLayout(boolean, int, int, int, int)	当此视图应为其所有子项指定大小和位置时调用。
      onSizeChanged(int, int, int, int)	在此视图的大小发生更改时调用。
      3,Drawing
      onDraw(Canvas)	视图应呈现其内容时调用。
      注意： 这不适用于3D图形。如果要使用3D图形，则必须扩展SurfaceView 而不是View，并从单独的线程中绘制。而且绘制用到显存，不会消耗java heap，即不会内存溢出。
      4,Event processing 
      onKeyDown(int, KeyEvent)	在发生新的键事件时调用。
      onKeyUp(int, KeyEvent)	在发生启动事件时调用。
      onTrackballEvent(MotionEvent)	当轨迹球运动事件发生时调用。
      onTouchEvent(MotionEvent)	发生触摸屏运动事件时调用。
      5,Focus
      onFocusChanged(boolean, int, Rect)	视图获得或失去焦点时调用。
      onWindowFocusChanged(boolean)	当包含视图的窗口增益或失去焦点时调用。
      6,Attaching
      onAttachedToWindow()	视图附加到窗口时调用。
      onDetachedFromWindow()	视图从其窗口分离时调用。
      onWindowVisibilityChanged(int)	当包含视图的窗口的可见性发生更改时调用。
      
      要创建完全自定义的组件：
      1，您可以扩展的最通用的视图，毫不奇怪，View因此您通常会首先扩展它以创建新的超级组件。
      2，您可以提供一个可以从XML获取属性和参数的构造函数，您也可以使用自己的属性和参数（可能是VU表的颜色和范围，或者针的宽度和阻尼等）。
      3，您可能希望在组件类中创建自己的事件侦听器，属性访问器和修改器，以及可能更复杂的行为。
      4，您几乎肯定想要覆盖onMeasure()，onDraw()如果您希望组件显示某些内容，也可能需要覆盖。虽然两者都有默认行为，但默认情况下onDraw()不会执行任何操作，默认情况下 onMeasure()将始终设置为100x100的大小 - 这可能不是您想要的。
      5，on...也可以根据需要覆盖 其他方法。
      
      要创建复合组件：
      1，通常的起点是某种布局，因此创建一个扩展布局的类。也许在组合框的情况下，我们可能使用具有水平方向的LinearLayout。请记住，其他布局可以嵌套在内部，因此复合组件可以是任意复杂和结构化的。请注意，就像使用Activity一样，您可以使用声明式（基于XML）方法来创建包含的组件，也可以从代码中以编程方式嵌套它们。
      2，在新类的构造函数中，获取超类所需的任何参数，并首先将它们传递给超类构造函数。然后，您可以设置其他视图以在新组件中使用; 这是您创建EditText字段和PopupList的位置。请注意，您还可以在XML中引入自己的属性和参数，这些属性和参数可以由构造函数提取和使用。
      3，您还可以为包含的视图可能生成的事件创建侦听器，例如，List Item的侦听器方法单击Listener以在创建列表时更新EditText的内容。
      4，您还可以使用访问器和修饰符创建自己的属性，例如，允许在组件中最初设置EditText值，并在需要时查询其内容。
      5，在扩展布局的情况下，您不需要覆盖 onDraw()和onMeasure()方法，因为布局将具有可能正常工作的默认行为。但是，如果需要，您仍然可以覆盖它们。
      6，您可以覆盖其他on...方法，例如 onKeyDown()，当按下某个键时，可能从组合框的弹出列表中选择某些默认值。
      总而言之，使用布局作为自定义控件的基础具有许多优点，包括：
      （1）您可以使用声明性XML文件指定布局，就像使用活动屏幕一样，或者您可以以编程方式创建视图并将它们嵌入到代码的布局中。
      （2）在onDraw()与onMeasure()方法（再加上大部分的其他on...方法）将可能有合适的行为，所以你不必重写它们。
      （3）最后，您可以非常快速地构造任意复杂的复合视图，并将它们重新使用，就像它们是单个组件一样。
      
      修改现有视图类型：
      创建自定义视图有一个更简单的选项，这在某些情况下很有用。如果某个组件已经非常类似于您想要的组件，则只需扩展该组件并覆盖您想要更改的行为即可。您可以使用完全自定义的组件执行所有操作，但是从View层次结构中的更专业的类开始，您还可以免费获得许多可能完全符合您需要的行为。
      
      
      
      